{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to CS12 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students taking historically difficult courses.\nIt offers students the chance to collaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture.\nSI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture and to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nIf you are in a Learning Community, attendance is mandatory.\n\n\nGuidelines:\n\n\n\n\nBe respectful. This includes silencing your cell phones and not using them during sessions.\n\n\nParticipate! You won\u2019t get very much out of SI if you don\u2019t.\n\n\nNo food or drink besides water. This is a rule placed by the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet.\n\n\nSign in, even if you are late.",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-cs12-si",
            "text": "This is where all of the labs will be posted.",
            "title": "Welcome to CS12 SI!"
        },
        {
            "location": "/#what-is-si",
            "text": "Supplemental Instruction is a series of weekly review sessions for students taking historically difficult courses.\nIt offers students the chance to collaborate, discuss challenging concepts, and study for exams.",
            "title": "What is SI?"
        },
        {
            "location": "/#what-isnt-si",
            "text": "Supplemental Instruction is not a lecture.\nSI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture and to help guide you in understanding the subject.",
            "title": "What isn\u2019t SI?"
        },
        {
            "location": "/#who-should-go",
            "text": "If you are in a Learning Community, attendance is mandatory.",
            "title": "Who should go?"
        },
        {
            "location": "/#guidelines",
            "text": "Be respectful. This includes silencing your cell phones and not using them during sessions.  Participate! You won\u2019t get very much out of SI if you don\u2019t.  No food or drink besides water. This is a rule placed by the administration. I will enforce it.  Late entry and early exit should be quiet.  Sign in, even if you are late.",
            "title": "Guidelines:"
        },
        {
            "location": "/dis01/",
            "text": "CS 10 Review\n\n\n1) Draw a conceptual model of a variable. Label the address, name, and contents of your variable at a minimum.\n\n\n2) Use your model from part 1 to draw a conceptual model of a vector.\n\n\n3) Descrive the difference between passing a variable by value and passing a variable by reference.\n\n\n4) List some types that should almost always be passed by reference. Why is this the case?\n\n\n5) Write a function that swaps the contents of two variables of type char.\n\n\n6) Write a function that reverses all the strings in a vector of strings.\n\n\n7) Write a function that takes as input a vector of strings and does the following: \n\n   Output 'True' to the terminal if more than half the strings in the vector have a length greater than 6.\n\n   Output 'False' to the terminal otherwise.\n\n\nBrain Teasers\n\n\nSince its right after winter break and your brains are dead and frankly so is your SI Leaders,\nheres some fun brain teasers to wake you up and get your brain gears working!\n\n\n1) What belongs to you, but others use it more?\n\n\n2) What dissapears the moment you say its name?\n\n\n3)",
            "title": "Discussion 1: CS 10 Review"
        },
        {
            "location": "/dis01/#cs-10-review",
            "text": "1) Draw a conceptual model of a variable. Label the address, name, and contents of your variable at a minimum.  2) Use your model from part 1 to draw a conceptual model of a vector.  3) Descrive the difference between passing a variable by value and passing a variable by reference.  4) List some types that should almost always be passed by reference. Why is this the case?  5) Write a function that swaps the contents of two variables of type char.  6) Write a function that reverses all the strings in a vector of strings.  7) Write a function that takes as input a vector of strings and does the following:  \n   Output 'True' to the terminal if more than half the strings in the vector have a length greater than 6. \n   Output 'False' to the terminal otherwise.",
            "title": "CS 10 Review"
        },
        {
            "location": "/dis01/#brain-teasers",
            "text": "Since its right after winter break and your brains are dead and frankly so is your SI Leaders,\nheres some fun brain teasers to wake you up and get your brain gears working!  1) What belongs to you, but others use it more?  2) What dissapears the moment you say its name?  3)",
            "title": "Brain Teasers"
        },
        {
            "location": "/lab01/",
            "text": "Introduction\n\n\nSelection sort is a naive sorting algorithm.\n\n\nGiven an unsorted vector of integers, find the position of the smallest element.\n\nSwap that element to index 0 of the vector.\n\nThen, find the smallest element in the index range \n[1, v.size()-1]\n.\n\nSwap that element to index 1 of the vector.\n\nThen, find the smallest element in the index range \n[2, v.size()-1]\n.\n\nSwap that element to index 2 of the vector.\n\nRepeat finding the smallest element and swapping into place until there are no more elements to sort.\n\n\nThis process guarantees a sorted vector at the end.\nIn the case described above, the vector will be in ascending order.\n\n\nStarter Code\n\n\nTake a look at the starter code below.\n\n\nWe will complete either \nfillVec\n or \nprintVec\n together.\n\n\n#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\n// This is a program that will run a SELECTION SORT on a vector\n\nusing namespace std;\n\nint min(const vector<int>& v, int);\nvoid selectionSort(vector<int>& v);\nvoid fillVec(vector<int>& v);\nvoid printVec(const vector<int>& v);\n\nint main() {\n    srand(time(0));\n\n    vector<int> test(10);\n\n    fillVec(test);\n    printVec(test);\n    selectionSort(test);\n    printVec(test);\n\n    return 0;\n}\n\n/* This function gets the position of the smallest element in the vector\n *\n * Accepts:\n *     const vector<int>& v - the vector to search\n *     int start            - the position to start looking for the smallest value\n * Returns:\n *     int - the position of the smallest element (-1 if there is no value)\n */\nint min(const vector<int>& v, int start) {\n    return -1;\n}\n\n/* Performs selection sort on the vector\n *\n * Accepts:\n *     vector<int>& v - the vector to sort\n * Returns:\n *     void\n */\nvoid selectionSort(vector<int>& v) {\n}\n\n/* Fills a vector with random values in [0, v.size()]\n * Accepts:\n *     vector<int>& v - the vector to fill with random data\n * Returns:\n *     void\n */\nvoid fillVec(vector<int>& v) {\n}\n\n/* Prints a vector to stdout\n *\n * Accepts:\n *     vector<int>& v - the vector to print\n * Returns:\n *     void\n */\nvoid printVec(const vector<int>& v) {\n}",
            "title": "Lab 1: Selection Sort Case Study"
        },
        {
            "location": "/lab01/#introduction",
            "text": "Selection sort is a naive sorting algorithm.  Given an unsorted vector of integers, find the position of the smallest element. \nSwap that element to index 0 of the vector. \nThen, find the smallest element in the index range  [1, v.size()-1] . \nSwap that element to index 1 of the vector. \nThen, find the smallest element in the index range  [2, v.size()-1] . \nSwap that element to index 2 of the vector. \nRepeat finding the smallest element and swapping into place until there are no more elements to sort.  This process guarantees a sorted vector at the end.\nIn the case described above, the vector will be in ascending order.",
            "title": "Introduction"
        },
        {
            "location": "/lab01/#starter-code",
            "text": "Take a look at the starter code below.  We will complete either  fillVec  or  printVec  together.  #include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n\n// This is a program that will run a SELECTION SORT on a vector\n\nusing namespace std;\n\nint min(const vector<int>& v, int);\nvoid selectionSort(vector<int>& v);\nvoid fillVec(vector<int>& v);\nvoid printVec(const vector<int>& v);\n\nint main() {\n    srand(time(0));\n\n    vector<int> test(10);\n\n    fillVec(test);\n    printVec(test);\n    selectionSort(test);\n    printVec(test);\n\n    return 0;\n}\n\n/* This function gets the position of the smallest element in the vector\n *\n * Accepts:\n *     const vector<int>& v - the vector to search\n *     int start            - the position to start looking for the smallest value\n * Returns:\n *     int - the position of the smallest element (-1 if there is no value)\n */\nint min(const vector<int>& v, int start) {\n    return -1;\n}\n\n/* Performs selection sort on the vector\n *\n * Accepts:\n *     vector<int>& v - the vector to sort\n * Returns:\n *     void\n */\nvoid selectionSort(vector<int>& v) {\n}\n\n/* Fills a vector with random values in [0, v.size()]\n * Accepts:\n *     vector<int>& v - the vector to fill with random data\n * Returns:\n *     void\n */\nvoid fillVec(vector<int>& v) {\n}\n\n/* Prints a vector to stdout\n *\n * Accepts:\n *     vector<int>& v - the vector to print\n * Returns:\n *     void\n */\nvoid printVec(const vector<int>& v) {\n}",
            "title": "Starter Code"
        },
        {
            "location": "/lab02/",
            "text": "Exercise 1\n\n\nWrite a program that lists all of its arguments.\n\n\nExample:\n\n\n$ ./a.out hi there 2 3 4 20\nhi there 2 3 4 20\n$\n\n\n\n\nExercise 2\n\n\nWrite a program that takes each integer in a file and outputs it on new file on separate lines.\nYou should ask for the name of the input and output files from the user.\n\n\nDo \nnot\n allow the input and output filenames to be the same!\n\n\nBonus 1\n:\nIf the file contains non-integer terms, do not put them in the resulting file.\n\n\nBonus 2\n:\nAllow the user to pass in filenames via command line arguments.\nThe first argument should be the input file name.\nThe second should be the output file name.\n\n\nIf only one argument is passed in, assume it is the input file name and ask for the output file name.\n\n\nIf no arguments are passed in, ask for both the input and output file names.\n\n\n\n\n\nExercise 3\n\n\nGiven a file containing a list of pairs of integers in the following format:\n\n\n\n\n0 1 \n\n3 1 \n\n9 10 \n\n16 93 \n\n20 90 \n\n3 9 \n\n\n\n\nWrite a program that outputs the sum of each pair of numbers on a newline in another file.\n\n\nThe file will only contain integers and will always be in the above format (hint, you can use\nthat to your advantage...)\n\n\nWrite your own sample file. The file names for both input and output are specified on the command line.\n\n\nBonus\n:\nIf the file contains non-integer terms, ignore them.\n\n\nExercise 4\n\n\nWrite a program that prompts the user to enter a pair of integers.\nRead those integers as \nstrings\n (either as one large string or two sepearte ones)\nand outputs thier sum to the terminal. \n\n\nThis program continuously prompts the user until they enter 'q'.\n\n\nHint: You will be needing string streams to do this.\n\n\nExtra Help\n\n\n\n\nC++.com Tutorial for File I/O",
            "title": "Lab 2: Streams"
        },
        {
            "location": "/lab02/#exercise-1",
            "text": "Write a program that lists all of its arguments.  Example:  $ ./a.out hi there 2 3 4 20\nhi there 2 3 4 20\n$",
            "title": "Exercise 1"
        },
        {
            "location": "/lab02/#exercise-2",
            "text": "Write a program that takes each integer in a file and outputs it on new file on separate lines.\nYou should ask for the name of the input and output files from the user.  Do  not  allow the input and output filenames to be the same!  Bonus 1 :\nIf the file contains non-integer terms, do not put them in the resulting file.  Bonus 2 :\nAllow the user to pass in filenames via command line arguments.\nThe first argument should be the input file name.\nThe second should be the output file name.  If only one argument is passed in, assume it is the input file name and ask for the output file name.  If no arguments are passed in, ask for both the input and output file names.",
            "title": "Exercise 2"
        },
        {
            "location": "/lab02/#exercise-3",
            "text": "Given a file containing a list of pairs of integers in the following format:   0 1  \n3 1  \n9 10  \n16 93  \n20 90  \n3 9    Write a program that outputs the sum of each pair of numbers on a newline in another file.  The file will only contain integers and will always be in the above format (hint, you can use\nthat to your advantage...)  Write your own sample file. The file names for both input and output are specified on the command line.  Bonus :\nIf the file contains non-integer terms, ignore them.",
            "title": "Exercise 3"
        },
        {
            "location": "/lab02/#exercise-4",
            "text": "Write a program that prompts the user to enter a pair of integers.\nRead those integers as  strings  (either as one large string or two sepearte ones)\nand outputs thier sum to the terminal.   This program continuously prompts the user until they enter 'q'.  Hint: You will be needing string streams to do this.",
            "title": "Exercise 4"
        },
        {
            "location": "/lab02/#extra-help",
            "text": "C++.com Tutorial for File I/O",
            "title": "Extra Help"
        },
        {
            "location": "/dis03/",
            "text": "Stucts and Classes\n\n\n\n\nRead me first!\n\n\n\n\nExample 1\n\n\nBelow is an example of classes and structs in C++. \nIf you don't understand all of this code that is \nperfectly ok\n.\nDo you best to trace the code and we will go through it together.\n\n\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Student{\n    int age;\n    string name;\n    string gender;\n};\n\nclass Avenger{\n  public:\n    string name;\n    int age;\n    string gender;\n    /* ussually, a classes data members are declared private\n       and it is bad practice to have them publicly available.\n       For the sake of example, they will be public here.*/\n    Avenger(){\n        name = \"Stan lee\";\n        age = 2018;\n        gender = \"Alien\";\n    }\n\n    Avenger(int age1, string name1, string gender1){\n        age = age1;\n        name = name1;\n        gender = gender1;\n    }\n};\n\nclass phone{\n  private:\n    string model;\n    int megapixels;\n    int screensize;\n\n  public:\n    string getModel(){ return model; }\n    int getMegapixels(){ return megapixels; }\n    int getScreensize(){ return megapixels; }\n\n    void setModel(string model){\n        this -> model = model;\n    }\n    void setMegapixels(int megapixels){\n        this -> megapixels = megapixels;   \n    }\n    void setScreensize(int screensize){\n        this -> screensize = screensize;\n    }\n};\n\nint main(){\n    Student iMan = {2, \"Tony Stank\", \"Male\"};\n    iMan.age = 52; // rdj is 52 irl :o\n    cout << iMan.age << \", \" << iMan.name << \", \" << iMan.gender << endl;\n\n    phone lame_phone;\n    lame_phone.setModel(\"IPhone\");\n    cout << iMan.name << \" most likely owns an \" << lame_phone.getModel() << \" because he's rich AF.\" << endl;\n    cout << endl;\n\n    Avenger tony;\n    Avenger wakanda(41, \"T'Challa\", \"Male\");\n    Avenger blackWidow(33, \"Nat\", \"Female\");\n    Avenger cap(36, \"Steve Rogers\", \"Bucky\");\n\n    vector<Avenger> avengers;\n    avengers.push_back(tony);\n    avengers.push_back(wakanda);\n    avengers.push_back(blackWidow);\n    avengers.push_back(cap);\n\n    for(int i = 0; i < avengers.size(); i ++){\n        cout << avengers.at(i).name << \" is \" << avengers.at(i).age << \" years old. They are a \" << avengers.at(i).gender << endl;\n    }\n    return 0;   \n}\n\n\n\n\nThere will almost certainly be something you don't understand in the code above, ask questions! We are here to help :)",
            "title": "Discussion 3: Classes"
        },
        {
            "location": "/dis03/#stucts-and-classes",
            "text": "Read me first!",
            "title": "Stucts and Classes"
        },
        {
            "location": "/dis03/#example-1",
            "text": "Below is an example of classes and structs in C++. \nIf you don't understand all of this code that is  perfectly ok .\nDo you best to trace the code and we will go through it together.  #include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Student{\n    int age;\n    string name;\n    string gender;\n};\n\nclass Avenger{\n  public:\n    string name;\n    int age;\n    string gender;\n    /* ussually, a classes data members are declared private\n       and it is bad practice to have them publicly available.\n       For the sake of example, they will be public here.*/\n    Avenger(){\n        name = \"Stan lee\";\n        age = 2018;\n        gender = \"Alien\";\n    }\n\n    Avenger(int age1, string name1, string gender1){\n        age = age1;\n        name = name1;\n        gender = gender1;\n    }\n};\n\nclass phone{\n  private:\n    string model;\n    int megapixels;\n    int screensize;\n\n  public:\n    string getModel(){ return model; }\n    int getMegapixels(){ return megapixels; }\n    int getScreensize(){ return megapixels; }\n\n    void setModel(string model){\n        this -> model = model;\n    }\n    void setMegapixels(int megapixels){\n        this -> megapixels = megapixels;   \n    }\n    void setScreensize(int screensize){\n        this -> screensize = screensize;\n    }\n};\n\nint main(){\n    Student iMan = {2, \"Tony Stank\", \"Male\"};\n    iMan.age = 52; // rdj is 52 irl :o\n    cout << iMan.age << \", \" << iMan.name << \", \" << iMan.gender << endl;\n\n    phone lame_phone;\n    lame_phone.setModel(\"IPhone\");\n    cout << iMan.name << \" most likely owns an \" << lame_phone.getModel() << \" because he's rich AF.\" << endl;\n    cout << endl;\n\n    Avenger tony;\n    Avenger wakanda(41, \"T'Challa\", \"Male\");\n    Avenger blackWidow(33, \"Nat\", \"Female\");\n    Avenger cap(36, \"Steve Rogers\", \"Bucky\");\n\n    vector<Avenger> avengers;\n    avengers.push_back(tony);\n    avengers.push_back(wakanda);\n    avengers.push_back(blackWidow);\n    avengers.push_back(cap);\n\n    for(int i = 0; i < avengers.size(); i ++){\n        cout << avengers.at(i).name << \" is \" << avengers.at(i).age << \" years old. They are a \" << avengers.at(i).gender << endl;\n    }\n    return 0;   \n}  There will almost certainly be something you don't understand in the code above, ask questions! We are here to help :)",
            "title": "Example 1"
        },
        {
            "location": "/lab03/",
            "text": "Exercise 1\n\n\nGiven the following struct and its instances:\n\n\nstruct Weapon{\n    int damage;\n    int durabilty;\n    string name;   \n};\n\n//weapon list\nWeapon Hulk_Buster = {9000,50, \"Hulk Buster\"};\nWeapon Mjolnir     = {5000,200,\"Mjolnir\"};\nWeapon Pistol      = {10,  100,\"Pistol\"};\nWeapon Lightsaber  = {50,  5,  \"Lightsaber\"};\nWeapon Arrow       = {20,  10, \"Arrow\"};\nWeapon Taser       = {60,  10, \"Taser\"};\nWeapon Shield      = {100, INT_MAX,\"Shield\"};\nWeapon Sling_Ring  = {1000,5,  \"Sling Ring\"};\nWeapon Ants        = {100, 10, \"Ants\"};\n\n//stones\nWeapon Mind_Stone    = {10000,INT_MAX,\"Mind Stone\"};\nWeapon Time_Stone    = {10000,INT_MAX,\"Time Stone\"};\nWeapon Space_Stone   = {10000,INT_MAX,\"Space Stone\"};\nWeapon Reality_Stone = {10000,INT_MAX,\"Reality Stone\"};\nWeapon Power_Stone   = {10000,INT_MAX,\"Power Stone\"};\nWeapon Soul_Stone    = {10000,INT_MAX,\"Soul Stone\"};\n\n\n\n\nCreate a class 'Avenger' which has the following attributes:\n\n\n\n\nname\n\n\nage\n\n\narsenal (a list of all usable weapons)\n\n\n\n\nAnd can perform the following operations:\n\n\n\n\nset name and corresponding getter\n\n\nset age and corresponding getter\n\n\nadd weapon to arsenal\n\n\nremove weapon from arsenal\n\n\ndisplay arsenal\n\n\n\n\nAnd of course don't forget the default constructor and a constructor that accepts name and age.\n\n\nExercise 2\n\n\nGiven the following code:\n\n\nint main(){\n    vector<Avenger> avengers;\n    Avenger Cap(\"Steve Rogers\", 100);\n    Avenger iMan(\"Anthony/Tony Stark\", 52);\n    Avenger bWidow(\"Nat\", 33);\n    Avenger Hulk(\"Bruce Banner\", 50 );\n    Avenger Thor(\"Thor Odinson\", 34);\n    Avenger Hawkeye(\"Clint Barton\", 47);\n    Avenger Vision(\"J.A.R.V.I.S\",2 );\n    Avenger sWitch(\"Wanda Maximoff\", 28 );\n    Avenger bPanther(\"T'Challa\", 42 );\n    Avenger antMan(\"Scott Lang\", 48 );\n    Avenger spiderMan(\"Peter Parker\", 21); //The actor is one month older exactly than Andre!\n    Avenger starLord(\"Peter Quill\", 38 );\n    Avenger omarvelous(\"Omar \", 20); \n    Avenger andreKhastro(\"Andre \", 21);   \n\n    // push back the values to vector avengers.\n\n    sort(avengers); //sorts in place\n    print(avengers);\n\n    return 0;\n}\n\n\n\n\nExpand on Exercise 1 by adding a sort function that sorts the above vector \nin place\n. \n\nIf you do not know what is meant by \"in place\", then ask :). \n\nLastly, print out the vector with each Avenger being printed out as \nname, age\n.",
            "title": "Lab 3: Classes"
        },
        {
            "location": "/lab03/#exercise-1",
            "text": "Given the following struct and its instances:  struct Weapon{\n    int damage;\n    int durabilty;\n    string name;   \n};\n\n//weapon list\nWeapon Hulk_Buster = {9000,50, \"Hulk Buster\"};\nWeapon Mjolnir     = {5000,200,\"Mjolnir\"};\nWeapon Pistol      = {10,  100,\"Pistol\"};\nWeapon Lightsaber  = {50,  5,  \"Lightsaber\"};\nWeapon Arrow       = {20,  10, \"Arrow\"};\nWeapon Taser       = {60,  10, \"Taser\"};\nWeapon Shield      = {100, INT_MAX,\"Shield\"};\nWeapon Sling_Ring  = {1000,5,  \"Sling Ring\"};\nWeapon Ants        = {100, 10, \"Ants\"};\n\n//stones\nWeapon Mind_Stone    = {10000,INT_MAX,\"Mind Stone\"};\nWeapon Time_Stone    = {10000,INT_MAX,\"Time Stone\"};\nWeapon Space_Stone   = {10000,INT_MAX,\"Space Stone\"};\nWeapon Reality_Stone = {10000,INT_MAX,\"Reality Stone\"};\nWeapon Power_Stone   = {10000,INT_MAX,\"Power Stone\"};\nWeapon Soul_Stone    = {10000,INT_MAX,\"Soul Stone\"};  Create a class 'Avenger' which has the following attributes:   name  age  arsenal (a list of all usable weapons)   And can perform the following operations:   set name and corresponding getter  set age and corresponding getter  add weapon to arsenal  remove weapon from arsenal  display arsenal   And of course don't forget the default constructor and a constructor that accepts name and age.",
            "title": "Exercise 1"
        },
        {
            "location": "/lab03/#exercise-2",
            "text": "Given the following code:  int main(){\n    vector<Avenger> avengers;\n    Avenger Cap(\"Steve Rogers\", 100);\n    Avenger iMan(\"Anthony/Tony Stark\", 52);\n    Avenger bWidow(\"Nat\", 33);\n    Avenger Hulk(\"Bruce Banner\", 50 );\n    Avenger Thor(\"Thor Odinson\", 34);\n    Avenger Hawkeye(\"Clint Barton\", 47);\n    Avenger Vision(\"J.A.R.V.I.S\",2 );\n    Avenger sWitch(\"Wanda Maximoff\", 28 );\n    Avenger bPanther(\"T'Challa\", 42 );\n    Avenger antMan(\"Scott Lang\", 48 );\n    Avenger spiderMan(\"Peter Parker\", 21); //The actor is one month older exactly than Andre!\n    Avenger starLord(\"Peter Quill\", 38 );\n    Avenger omarvelous(\"Omar \", 20); \n    Avenger andreKhastro(\"Andre \", 21);   \n\n    // push back the values to vector avengers.\n\n    sort(avengers); //sorts in place\n    print(avengers);\n\n    return 0;\n}  Expand on Exercise 1 by adding a sort function that sorts the above vector  in place .  \nIf you do not know what is meant by \"in place\", then ask :).  \nLastly, print out the vector with each Avenger being printed out as  name, age .",
            "title": "Exercise 2"
        },
        {
            "location": "/lab04/",
            "text": "Modular Compilation\n\n\nCompile each .cpp file separately, and link to gether to generate an executable.\n\n\nExercise 1\n\n\nCreate a program with the following classes and attribrutes:\n\n\n\n\n\n\nFood\n\n\n\n\nname of food\n\n\ncalories\n\n\nprotien\n\n\ncarbs\n\n\n\n\n\n\n\n\nMeal\n\n\n\n\nvector of food\n\n\nname of meal\n\n\ntotal calories\n\n\ntotal protien\n\n\ntotal carbs\n\n\n\n\n\n\n\n\nEach class should have its own \n.cpp\n and header files.\nDefine the default constructor for each class and one other constructor with your choice of parameters.\n\n\nThe meal class needs to overload the \n+\n operator and will be used like so:\n\n\n  Meal lunch;\n  Food sandwich;\n  Food apple;\n\n  lunch = lunch + sandwhich;\n\n\n\n\nWhere here the food item \nsandwich\n was added to the \nlunch\n's food vector.\n\n\nhint:\n it would make things easier to made the meal class a \nfriend\n of the Food class.\nThis allows instances of the Meal classes to access the private data members of the Food class.\nTo do this, simply include the following line of code under \npublic:\n in the Food class:\n\n\n  friend class Meal;\n\n\n\n\nBonus:\n Make the operator+ overload return a \nvoid\n and work with the following code below:\n\n\n  Meal lunch;\n  Food sandwich;\n  Food apple;\n\n  lunch + sandwhich;\n\n\n\n\nExercise 2\n\n\nOveride the ostream operator \noperator<<\n for the Meal class. \nPrint out an instance of the meal class in the following manner:\n\n\nname of meal: ____\ncalories: _\nprotein: _\nproducts: ___, ___, ____\n\n\n\n\nTo do this, it is also recommended you overload the \noperator<<\n for the Food class as well.",
            "title": "Lab 4: Classes, Part 2"
        },
        {
            "location": "/lab04/#modular-compilation",
            "text": "Compile each .cpp file separately, and link to gether to generate an executable.",
            "title": "Modular Compilation"
        },
        {
            "location": "/lab04/#exercise-1",
            "text": "Create a program with the following classes and attribrutes:    Food   name of food  calories  protien  carbs     Meal   vector of food  name of meal  total calories  total protien  total carbs     Each class should have its own  .cpp  and header files.\nDefine the default constructor for each class and one other constructor with your choice of parameters.  The meal class needs to overload the  +  operator and will be used like so:    Meal lunch;\n  Food sandwich;\n  Food apple;\n\n  lunch = lunch + sandwhich;  Where here the food item  sandwich  was added to the  lunch 's food vector.  hint:  it would make things easier to made the meal class a  friend  of the Food class.\nThis allows instances of the Meal classes to access the private data members of the Food class.\nTo do this, simply include the following line of code under  public:  in the Food class:    friend class Meal;  Bonus:  Make the operator+ overload return a  void  and work with the following code below:    Meal lunch;\n  Food sandwich;\n  Food apple;\n\n  lunch + sandwhich;",
            "title": "Exercise 1"
        },
        {
            "location": "/lab04/#exercise-2",
            "text": "Overide the ostream operator  operator<<  for the Meal class. \nPrint out an instance of the meal class in the following manner:  name of meal: ____\ncalories: _\nprotein: _\nproducts: ___, ___, ____  To do this, it is also recommended you overload the  operator<<  for the Food class as well.",
            "title": "Exercise 2"
        },
        {
            "location": "/dis05/",
            "text": "Arrays\n\n\nSimilar to \nvector\n an array is a list of objects of a certain type.\nArrays however are more primitive and are a basic type in c++.\nNothing has to be included to use them, (no \n#include\n necessary)\n\n\nAn array can be declared like so:\n\n\n//datatype name[number of elements]\nint arr[10]; // an array called 'arr' that holds 10 integers\nchar c_arr[20]; // an array called 'c_arr' that holds 20 char's\n\n\n\n\nHowever, arrays do not have convenient member functions like vectors do.\nArrays do not have \n.at()\n, \n.push_back()\n, \n.size()\n etc.\n\n\nArrays have a set size at creation specified in the square brackets as seen above.\nA size must be specified and specifying no size will result in a compile time error.\nThe size of the array cannot change.\n\n\nInstead of using \n.at()\n arrays indicies can be accessed and set using the square brackets \n[]\n.\nFor example:\n\n\nint arr[3];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n\nfor(int i = 0; i < 3; i++){\n    cout << arr[i] << \" \";\n}\ncout << endl;\n\n\n\n\n\nwill result in the following output:\n\n\n1 2 3 \n\n\n\n\n\nCode Tracing\n\n\nWhat is the output of the following code?\n\n\n\n#include <iostream>\n\nusing namespace std;\n\nvoid setChar(char arr[], char c, int pos){\n    arr[pos] = c;\n    return;\n}\n\nint main(){\n    char c_arr[6];\n    setChar(c_arr, 'c', 0);\n    setChar(c_arr, 'a', 1);\n    setChar(c_arr, 'r', 2);\n    setChar(c_arr, 'e', 3);\n    setChar(c_arr, 'f', 4);\n    setChar(c_arr, 'u', 5);\n    setChar(c_arr, 'l', 6);\n\n    for(int i = 0; i < 7; i ++){\n       cout << c_arr[i];\n    }\n\n    return 0;\n}",
            "title": "Dis 5: Arrays"
        },
        {
            "location": "/dis05/#arrays",
            "text": "Similar to  vector  an array is a list of objects of a certain type.\nArrays however are more primitive and are a basic type in c++.\nNothing has to be included to use them, (no  #include  necessary)  An array can be declared like so:  //datatype name[number of elements]\nint arr[10]; // an array called 'arr' that holds 10 integers\nchar c_arr[20]; // an array called 'c_arr' that holds 20 char's  However, arrays do not have convenient member functions like vectors do.\nArrays do not have  .at() ,  .push_back() ,  .size()  etc.  Arrays have a set size at creation specified in the square brackets as seen above.\nA size must be specified and specifying no size will result in a compile time error.\nThe size of the array cannot change.  Instead of using  .at()  arrays indicies can be accessed and set using the square brackets  [] .\nFor example:  int arr[3];\narr[0] = 1;\narr[1] = 2;\narr[2] = 3;\n\nfor(int i = 0; i < 3; i++){\n    cout << arr[i] << \" \";\n}\ncout << endl;  will result in the following output:  1 2 3",
            "title": "Arrays"
        },
        {
            "location": "/dis05/#code-tracing",
            "text": "What is the output of the following code?  \n#include <iostream>\n\nusing namespace std;\n\nvoid setChar(char arr[], char c, int pos){\n    arr[pos] = c;\n    return;\n}\n\nint main(){\n    char c_arr[6];\n    setChar(c_arr, 'c', 0);\n    setChar(c_arr, 'a', 1);\n    setChar(c_arr, 'r', 2);\n    setChar(c_arr, 'e', 3);\n    setChar(c_arr, 'f', 4);\n    setChar(c_arr, 'u', 5);\n    setChar(c_arr, 'l', 6);\n\n    for(int i = 0; i < 7; i ++){\n       cout << c_arr[i];\n    }\n\n    return 0;\n}",
            "title": "Code Tracing"
        },
        {
            "location": "/lab05/",
            "text": "Mock Midterm\n\n\nClick on the link \n\nhere\n\nto be navigated to the SI mock midterm!\nMake sure you are logged in witht your student email to view the document!\nAnswer key will be posted later.\n\n\nASK QUESTIONS!\n\n\n-CS12 SI team :)",
            "title": "Lab 5: Mock Midterm"
        },
        {
            "location": "/lab05/#mock-midterm",
            "text": "Click on the link  here \nto be navigated to the SI mock midterm!\nMake sure you are logged in witht your student email to view the document!\nAnswer key will be posted later.  ASK QUESTIONS!  -CS12 SI team :)",
            "title": "Mock Midterm"
        },
        {
            "location": "/dis06/",
            "text": "Pointers\n\n\nWhere most variables store values, a pointer is a variable that stores a memory address.\nA pointer is denoted by appending a \n*\n character before the variable name.\nEither of the following syntaxes are accepted:\n\n\nint* n;\n or \nint *n;\n\n\nTo get the memory address of an already declared varaible (take \nint n = 0;\n for example),\nwe use the address of operator \n&\n.\n\n\nint n = 0;\nint *ptr = &n;\n\n\n\n\nTry printing out variable ptr to see the value of the memory address.\n(The address of operator should look familiar, think reference paramaters..)\n\n\nThe memory address of a pointer can be 'dereferenced' by using the dereference operator \n*\n.\nDereferncing a pointer returns the value at that memory location. For example:\n\n\nint a = 5;\nint *ptr = &a;\n\ncout << \"a's value: \" << a << endl;\ncout << \"a's address: \" << &a < endl;\ncout << \"the adress ptr points to: \" << ptr << endl;\ncout << \"value that ptr points to: \" << *ptr << endl;\ncout << \"adress of ptr: \" << &ptr << endl;\n\n\n\n\nshould print\n\n\n5\n0x00c8b\n0x00c8b\n5\n0x00d3c\n\n\n\n\nNote that the memory addresses will likely differ\n\n\nDereferncing a pointer can also be used to set the value at that location:\n\n\nint n = 5;\nint* ptr = &n;\n*ptr = n + 1;\ncout << *ptr\n\n\n\n\nwill print:\n\n\n6\n\n\n\n\nDangling Pointers\n\n\nPointers if set to incorrect values can cause \nsegmentations faults\n or shorter, seg faults. \nIf a seg fault is thrown, that means the code was trying to access a memory location it does not have access to.\n\n\nJust like an integer, if you write \nint* ptr;\n the value of the ptr will be garbage.\nTo fix this problem, we set the ptr = 0;\n\n\nCode Tracing\n\n\ngoo.gl/62Tb7i",
            "title": "Dis 6: Pointers and Dynamic Memory"
        },
        {
            "location": "/dis06/#pointers",
            "text": "Where most variables store values, a pointer is a variable that stores a memory address.\nA pointer is denoted by appending a  *  character before the variable name.\nEither of the following syntaxes are accepted:  int* n;  or  int *n;  To get the memory address of an already declared varaible (take  int n = 0;  for example),\nwe use the address of operator  & .  int n = 0;\nint *ptr = &n;  Try printing out variable ptr to see the value of the memory address.\n(The address of operator should look familiar, think reference paramaters..)  The memory address of a pointer can be 'dereferenced' by using the dereference operator  * .\nDereferncing a pointer returns the value at that memory location. For example:  int a = 5;\nint *ptr = &a;\n\ncout << \"a's value: \" << a << endl;\ncout << \"a's address: \" << &a < endl;\ncout << \"the adress ptr points to: \" << ptr << endl;\ncout << \"value that ptr points to: \" << *ptr << endl;\ncout << \"adress of ptr: \" << &ptr << endl;  should print  5\n0x00c8b\n0x00c8b\n5\n0x00d3c  Note that the memory addresses will likely differ  Dereferncing a pointer can also be used to set the value at that location:  int n = 5;\nint* ptr = &n;\n*ptr = n + 1;\ncout << *ptr  will print:  6",
            "title": "Pointers"
        },
        {
            "location": "/dis06/#dangling-pointers",
            "text": "Pointers if set to incorrect values can cause  segmentations faults  or shorter, seg faults. \nIf a seg fault is thrown, that means the code was trying to access a memory location it does not have access to.  Just like an integer, if you write  int* ptr;  the value of the ptr will be garbage.\nTo fix this problem, we set the ptr = 0;",
            "title": "Dangling Pointers"
        },
        {
            "location": "/dis06/#code-tracing",
            "text": "goo.gl/62Tb7i",
            "title": "Code Tracing"
        },
        {
            "location": "/lab06/",
            "text": "Excercise 1\n\n\nImplement the following functions listed below, this lab serves as an mini-intro to linked lists.\n\n\n#include <iostream>\n\nusing namespace std;\n\nstruct Block{\n  public:\n    int val;\n    Block * next;\n    Block(int val): val(val), next(0) {};\n};\n\nvoid addBlock(Block * start, int val){\n\n}\n\nvoid printBLockChain(Block * b){\n\n}\n\n//remove the first\nvoid removeFirstBlock(Block *&b){\n\n}\n//remove last\nvoid removeLastBlock(Block * b){\n\n}\n\nint main(){\n    Block * genesis = new Block(3);\n    addBlock(genesis,5);\n    addBlock(genesis,8);\n    addBlock(genesis,10);\n    addBlock(genesis,3);\n    printBLockChain(genesis);\n\n    // do more testing here\n\n    return 0;\n}\n\n\n//01001111 01101101 01100001 01110010 00100000 01101000 01100001 01110011 00100000 00110011 00110000 00110000 00100000 01100011 01101111 01101110 01100110 01101001 01110010 01101101 01100101 01100100\n//01110111 01100001 01101001 01100110 01110101 00001010",
            "title": "Lab 6: Dynamic Memory, and Pointers"
        },
        {
            "location": "/lab06/#excercise-1",
            "text": "Implement the following functions listed below, this lab serves as an mini-intro to linked lists.  #include <iostream>\n\nusing namespace std;\n\nstruct Block{\n  public:\n    int val;\n    Block * next;\n    Block(int val): val(val), next(0) {};\n};\n\nvoid addBlock(Block * start, int val){\n\n}\n\nvoid printBLockChain(Block * b){\n\n}\n\n//remove the first\nvoid removeFirstBlock(Block *&b){\n\n}\n//remove last\nvoid removeLastBlock(Block * b){\n\n}\n\nint main(){\n    Block * genesis = new Block(3);\n    addBlock(genesis,5);\n    addBlock(genesis,8);\n    addBlock(genesis,10);\n    addBlock(genesis,3);\n    printBLockChain(genesis);\n\n    // do more testing here\n\n    return 0;\n}\n\n\n//01001111 01101101 01100001 01110010 00100000 01101000 01100001 01110011 00100000 00110011 00110000 00110000 00100000 01100011 01101111 01101110 01100110 01101001 01110010 01101101 01100101 01100100\n//01110111 01100001 01101001 01100110 01110101 00001010",
            "title": "Excercise 1"
        },
        {
            "location": "/lab07/",
            "text": "We are going to make a \nTrain\n linked list today.\n\n\nCart Node\n\n\nBelow is the code for a Cart struct.\nEach \nCart\n object should \npoint\n to the \nCart\n before it and the \nCart\n after it.\nThis makes the Train a doubly linked list.\n\n\nstruct Cart{\n  int weight;\n  Cart * prev;\n  Cart * next;\n  Cart(int weight): weight(weight), prev(0), next(0){};\n};\n\n\n\n\nTrain List\n\n\nThe Train class is a linked list composed of Cart objects.\nBelow is the class definition\n\n\nclass Train{\n    private:\n      Cart * head;\n      Cart * tail;\n\n    public:\n      //constructor\n      Train(): head(0),tail(0){}\n\n      //add a cart to the end\n      void addLastCart(int weight);\n\n      //add a cart to the beginning\n      void addFirstCart(int weight);\n\n      //view the entire train starting from the head\n      void viewTrainForwards();\n\n      //view the train starting from the back\n      void viewTrainBackwards();\n\n      //count number of carts with given weight\n      int cartsWithWeight(int weight);\n\n      void printHead();\n\n      void printTail();\n\n\n//01000001 01101110 01100100 01110010 01100101 00100000 01101001 01110011 00100000 01110100 01101000 01100101 00100000 01110010 01101111 01101100 01101100 01101001 00100000 01100010 01100001 01100011 01101011 01110000 01100001 01100011 01101011 00100000 01101011 01101001 01101110 01100100 00100000 01101111 01100110 00100000 01100111 01110101 01111001\n\n};\n\nImplement the functions of the class as listed above, ask if you need help :)",
            "title": "Lab 7: Linked List"
        },
        {
            "location": "/lab07/#cart-node",
            "text": "Below is the code for a Cart struct.\nEach  Cart  object should  point  to the  Cart  before it and the  Cart  after it.\nThis makes the Train a doubly linked list.  struct Cart{\n  int weight;\n  Cart * prev;\n  Cart * next;\n  Cart(int weight): weight(weight), prev(0), next(0){};\n};",
            "title": "Cart Node"
        },
        {
            "location": "/lab07/#train-list",
            "text": "The Train class is a linked list composed of Cart objects.\nBelow is the class definition  class Train{\n    private:\n      Cart * head;\n      Cart * tail;\n\n    public:\n      //constructor\n      Train(): head(0),tail(0){}\n\n      //add a cart to the end\n      void addLastCart(int weight);\n\n      //add a cart to the beginning\n      void addFirstCart(int weight);\n\n      //view the entire train starting from the head\n      void viewTrainForwards();\n\n      //view the train starting from the back\n      void viewTrainBackwards();\n\n      //count number of carts with given weight\n      int cartsWithWeight(int weight);\n\n      void printHead();\n\n      void printTail();\n\n\n//01000001 01101110 01100100 01110010 01100101 00100000 01101001 01110011 00100000 01110100 01101000 01100101 00100000 01110010 01101111 01101100 01101100 01101001 00100000 01100010 01100001 01100011 01101011 01110000 01100001 01100011 01101011 00100000 01101011 01101001 01101110 01100100 00100000 01101111 01100110 00100000 01100111 01110101 01111001\n\n};\n\nImplement the functions of the class as listed above, ask if you need help :)",
            "title": "Train List"
        },
        {
            "location": "/dis08/",
            "text": "Recursion\n\n\nPreviously you have learned how to make functions. \nFunctions can be called in other functions. \nBut have you ever wondered, can functions call themselves??????? :O omg!! woo no way!!\n\n\nFunctions that call themselves are called \nrecursive functions\n. \nAn example of one can be seen below:\n\n\nvoid printRecursive(){\n    cout << \"I will print forver!!! Muahaha\" << endl;\n    printRecursive();\n    return;\n}\n\n\n\n\nTracing through the code above, the \nprintRecursive()\n function is called on the third line.\nWhen this function is called, a copy of the current 'state' of the program is placed on the stack.\n\n\nThe program then begins execution at the beginning of the \nprintRecursive()\n function like any other function call.\n\n\nBase Case\n\n\nIn the example above, the printRecursive function will keep calling itself until the program runs out of memory\n(called a stack overflow in this case since we are adding to the stack each recursive call).\n\n\nSince we most likely do not want to be causing infinite loops, we need a way to make sure the \nrecursive call only  happens in certain cases. We do this by having a base case. Ex:\n\n\nint i = 0;\nvoid printRecursive(){\n    cout << \"I will not print forever. :(\" << endl;\n    i ++;\n    if( i != 10){\n    printRecursive()\n    }\n    return;\n}\n\n\n\n\nIn this case the line 'I will not print forever. :(' prints ten times.\nThe base case is when \ni\n is equal to 10.\nThis program will keep calling the recursive function while the base case is not true.\n\n\nCode Tracing\n\n\nDo some of the code tracing to familiarize yourself with recursion.\n\n\n1)\n\n\nint main(){\n    int n = 0;\n    cout << \"How many times will I print?\" << endl;\n    if(n == 1){\n        return 0;\n    }\n    else{\n        main();\n    }\n\n    return 0;\n}\n\n\n\n\n2)\n\n\nint flower(int n){\n    return n > 10 ? -10 : flower(n+1);\n    /* The above is called a \"Ternary operator\"\n       Ask your SI leader for what it does if you do not understand. \n\n       The following is equivalent:\n\n       if (n > 10){\n           return -10;\n       }else{\n           return flower(n+1);\n       }\n       */\n}\n\nint main(){\n    cout << flower(9);\n    return 0;\n}\n\n\n\n\n3)\n\n\nint even(int n){\n    if(!(n%2)){\n        return n;\n    }\n    return even(n-1);\n\n}\n\n\nint main(){\n    even(323525643);\n    return 0;\n}\n\n\n\n\n4)\n\n\nint three(int n){\n    return 300;\n\n}\n\nint two(int n){\n    if(n == 0){\n        return three(n);\n    }\n    return 1 + two(n-1);\n\n}\n\nint one(int n){\n    if(n == 0 || n == 1){\n        return two(n*2);\n    }\n    cout << n << \" \";\n    return one(n-1) + one(n-2);\n\n}\n\nint main(){\n    cout << one(4);\n    return 0;\n}\n//00100010 01010111 01100101 00100000 01101110 01100101 01100101 01100100 00100000 01110100 01101111 00100000 01100111 01101111 00100000 01100100 01100101 01100101 01110000 01100101 01110010 00100010",
            "title": "Dis 8: Recursion"
        },
        {
            "location": "/dis08/#recursion",
            "text": "Previously you have learned how to make functions. \nFunctions can be called in other functions. \nBut have you ever wondered, can functions call themselves??????? :O omg!! woo no way!!  Functions that call themselves are called  recursive functions . \nAn example of one can be seen below:  void printRecursive(){\n    cout << \"I will print forver!!! Muahaha\" << endl;\n    printRecursive();\n    return;\n}  Tracing through the code above, the  printRecursive()  function is called on the third line.\nWhen this function is called, a copy of the current 'state' of the program is placed on the stack.  The program then begins execution at the beginning of the  printRecursive()  function like any other function call.",
            "title": "Recursion"
        },
        {
            "location": "/dis08/#base-case",
            "text": "In the example above, the printRecursive function will keep calling itself until the program runs out of memory\n(called a stack overflow in this case since we are adding to the stack each recursive call).  Since we most likely do not want to be causing infinite loops, we need a way to make sure the \nrecursive call only  happens in certain cases. We do this by having a base case. Ex:  int i = 0;\nvoid printRecursive(){\n    cout << \"I will not print forever. :(\" << endl;\n    i ++;\n    if( i != 10){\n    printRecursive()\n    }\n    return;\n}  In this case the line 'I will not print forever. :(' prints ten times.\nThe base case is when  i  is equal to 10.\nThis program will keep calling the recursive function while the base case is not true.",
            "title": "Base Case"
        },
        {
            "location": "/dis08/#code-tracing",
            "text": "Do some of the code tracing to familiarize yourself with recursion.  1)  int main(){\n    int n = 0;\n    cout << \"How many times will I print?\" << endl;\n    if(n == 1){\n        return 0;\n    }\n    else{\n        main();\n    }\n\n    return 0;\n}  2)  int flower(int n){\n    return n > 10 ? -10 : flower(n+1);\n    /* The above is called a \"Ternary operator\"\n       Ask your SI leader for what it does if you do not understand. \n\n       The following is equivalent:\n\n       if (n > 10){\n           return -10;\n       }else{\n           return flower(n+1);\n       }\n       */\n}\n\nint main(){\n    cout << flower(9);\n    return 0;\n}  3)  int even(int n){\n    if(!(n%2)){\n        return n;\n    }\n    return even(n-1);\n\n}\n\n\nint main(){\n    even(323525643);\n    return 0;\n}  4)  int three(int n){\n    return 300;\n\n}\n\nint two(int n){\n    if(n == 0){\n        return three(n);\n    }\n    return 1 + two(n-1);\n\n}\n\nint one(int n){\n    if(n == 0 || n == 1){\n        return two(n*2);\n    }\n    cout << n << \" \";\n    return one(n-1) + one(n-2);\n\n}\n\nint main(){\n    cout << one(4);\n    return 0;\n}\n//00100010 01010111 01100101 00100000 01101110 01100101 01100101 01100100 00100000 01110100 01101111 00100000 01100111 01101111 00100000 01100100 01100101 01100101 01110000 01100101 01110010 00100010",
            "title": "Code Tracing"
        }
    ]
}